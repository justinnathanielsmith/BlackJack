package io.github.smithjustinn.ui.game

import app.cash.turbine.test
import com.arkivanov.decompose.DefaultComponentContext
import dev.mokkery.answering.returns
import dev.mokkery.every
import dev.mokkery.everySuspend
import dev.mokkery.matcher.any
import io.github.smithjustinn.domain.models.CardSymbolTheme
import io.github.smithjustinn.domain.models.DifficultyType
import io.github.smithjustinn.domain.models.GameMode
import io.github.smithjustinn.domain.models.MemoryGameState
import io.github.smithjustinn.domain.models.SavedGame
import io.github.smithjustinn.test.BaseComponentTest
import kotlinx.coroutines.flow.MutableStateFlow
import kotlin.test.BeforeTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFalse

class GameResumeExploitTest : BaseComponentTest() {
    @BeforeTest
    override fun setUp() {
        super.setUp()
        every { context.settingsRepository.isWalkthroughCompleted } returns MutableStateFlow(true)
        every { context.settingsRepository.isPeekEnabled } returns MutableStateFlow(false)
        every { context.settingsRepository.isMusicEnabled } returns MutableStateFlow(true)
        every { context.settingsRepository.isSoundEnabled } returns MutableStateFlow(true)
        every { context.playerEconomyRepository.selectedThemeId } returns MutableStateFlow("GEOMETRIC")
        every { context.playerEconomyRepository.selectedSkin } returns MutableStateFlow(CardSymbolTheme.CLASSIC)
        everySuspend { context.shopItemRepository.getShopItems() } returns emptyList()
        every { context.gameStatsRepository.getAllStats() } returns MutableStateFlow(emptyList())
        everySuspend { context.gameStateRepository.saveGameState(any(), any()) } returns Unit
        everySuspend { context.gameStateRepository.clearSavedGameState() } returns Unit
    }

    @Test
    fun `busted game should clear saved state immediately and NOT be resumable`() =
        runTest { lifecycle ->
            // Given a state that is busted (GameOver)
            val bustedState =
                MemoryGameState(
                    pairCount = 8,
                    isGameOver = true,
                    isBusted = true,
                    isGameWon = false,
                )

            // Mock that the repository HAS this busted state saved (the "exploit" state)
            everySuspend { context.gameStateRepository.getSavedGameState() } returns
                SavedGame(bustedState, 30L)

            // When initializing the component
            val component =
                DefaultGameComponent(
                    componentContext = DefaultComponentContext(lifecycle = lifecycle),
                    appGraph = context.appGraph,
                    args =
                        GameArgs(
                            pairCount = 8,
                            mode = GameMode.TIME_ATTACK,
                            difficulty = DifficultyType.CASUAL,
                            forceNewGame = false,
                        ),
                    onBackClicked = {},
                )
            testDispatcher.scheduler.runCurrent()

            // Then it should NOT resume the busted game, but start a NEW one
            component.state.test {
                val state = awaitItem()
                assertFalse(state.game.isGameOver, "Should have started a new game instead of resuming busted one")
                assertFalse(state.game.isBusted, "New game should not be busted")

                // Verification: The component should have cleared the invalid save during init
                // Note: UseCases are already mocked to use these repositories in MokkeryTestContext
            }
        }

    @Test
    fun `won game should NOT be resumable`() =
        runTest { lifecycle ->
            // Given a state that is won
            val wonState =
                MemoryGameState(
                    pairCount = 8,
                    isGameOver = true,
                    isGameWon = true,
                )

            everySuspend { context.gameStateRepository.getSavedGameState() } returns
                SavedGame(wonState, 10L)

            // When initializing
            val component =
                DefaultGameComponent(
                    componentContext = DefaultComponentContext(lifecycle = lifecycle),
                    appGraph = context.appGraph,
                    args =
                        GameArgs(
                            pairCount = 8,
                            mode = GameMode.TIME_ATTACK,
                            difficulty = DifficultyType.CASUAL,
                            forceNewGame = false,
                        ),
                    onBackClicked = {},
                )
            testDispatcher.scheduler.runCurrent()

            // Then it should start a NEW game
            component.state.test {
                val state = awaitItem()
                assertFalse(state.game.isGameOver, "Should have started a new game instead of resuming won one")
            }
        }

    @Test
    fun `mismatched parameters should NOT be resumable`() =
        runTest { lifecycle ->
            // Given a saved game for 12 pairs
            val savedState = MemoryGameState(pairCount = 12)
            everySuspend { context.gameStateRepository.getSavedGameState() } returns
                SavedGame(savedState, 50L)

            // When trying to "resume" into a 8 pair game
            val component =
                DefaultGameComponent(
                    componentContext = DefaultComponentContext(lifecycle = lifecycle),
                    appGraph = context.appGraph,
                    args =
                        GameArgs(
                            pairCount = 8,
                            mode = GameMode.TIME_ATTACK,
                            difficulty = DifficultyType.CASUAL,
                            forceNewGame = false,
                        ),
                    onBackClicked = {},
                )
            testDispatcher.scheduler.runCurrent()

            // Then it should ignore the 12-pair save and start 8-pair new game
            component.state.test {
                val state = awaitItem()
                assertEquals(8, state.game.pairCount)
            }
        }
}
